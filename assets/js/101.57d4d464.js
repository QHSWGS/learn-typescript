(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{374:function(e,t,a){"use strict";a.r(t);var s=a(14),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"usememo与usecallback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usememo与usecallback"}},[e._v("#")]),e._v(" useMemo与useCallback")]),e._v(" "),t("p",[t("code",[e._v("useMemo")]),e._v("和"),t("code",[e._v("useCallback")]),e._v("都可缓存函数的引用或值，从更细的角度来说"),t("code",[e._v("useMemo")]),e._v("则返回一个缓存的值，"),t("code",[e._v("useCallback")]),e._v("是返回一个缓存函数的引用。")]),e._v(" "),t("h2",{attrs:{id:"usememo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[e._v("#")]),e._v(" useMemo")]),e._v(" "),t("p",[t("code",[e._v("useMemo")]),e._v("的"),t("code",[e._v("TS")]),e._v("定义可以看出，范型"),t("code",[e._v("T")]),e._v("在"),t("code",[e._v("useMemo")]),e._v("中是一个返回的值类型。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type DependencyList = ReadonlyArray<any>;\n\nfunction useMemo<T>(factory: () => T, deps: DependencyList | undefined): T;\n")])])]),t("p",[e._v("下面是"),t("code",[e._v("useMemo")]),e._v("的简单示例，在"),t("code",[e._v("a")]),e._v("和"),t("code",[e._v("b")]),e._v("的变量值不变的情况下，"),t("code",[e._v("memoizedValue")]),e._v("的值不变，在此时"),t("code",[e._v("useMemo")]),e._v("函数的第一个参数也就是"),t("code",[e._v("computeExpensiveValue")]),e._v("函数不会被执行，从而达到节省计算量的目的。")]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" memoizedValue "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("useMemo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("computeExpensiveValue")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("把创建函数"),t("code",[e._v("factory: () => T")]),e._v("和依赖项数组"),t("code",[e._v("deps: DependencyList | undefined")]),e._v("作为参数传入 "),t("code",[e._v("useMemo")]),e._v("，它仅会在某个依赖项改变时才重新计算"),t("code",[e._v("memoized")]),e._v(" 值，这种优化有助于避免在每次渲染时都进行高开销的计算，例如上文的"),t("code",[e._v("computeExpensiveValue")]),e._v("是需要一个大量计算的函数时，"),t("code",[e._v("useMemo")]),e._v("有助于减少性能开销，以防止"),t("code",[e._v("Js")]),e._v("太多次长时间运行计算导致页面无响应。"),t("br"),e._v("\n此外，传入"),t("code",[e._v("useMemo")]),e._v("的函数会在渲染期间执行，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于"),t("code",[e._v("useEffect")]),e._v("的适用范畴，而不是"),t("code",[e._v("useMemo")]),e._v("。如果没有提供依赖项数组，"),t("code",[e._v("useMemo")]),e._v("在每次渲染时都会计算新的值。"),t("br"),e._v(" "),t("code",[e._v("eslint")]),e._v("的"),t("code",[e._v("eslint-plugin-react-hooks")]),e._v("中的"),t("code",[e._v("exhaustive-deps")]),e._v("规则可以在添加错误依赖时发出警告并给出修复建议。"),t("br"),e._v("\n相比较于"),t("code",[e._v("useEffect")]),e._v("看起来和"),t("code",[e._v("Vue")]),e._v("的"),t("code",[e._v("Watch")]),e._v("很像，但是思想方面是不同的，"),t("code",[e._v("Vue")]),e._v("是监听值的变化而"),t("code",[e._v("React")]),e._v("是用以处理副作用。在"),t("code",[e._v("useMemo")]),e._v("方面就和"),t("code",[e._v("Vue")]),e._v("的"),t("code",[e._v("computed")]),e._v("非常类似了，同样都属于缓存依赖项的计算结果，当然在实现上是完全不同的。")]),e._v(" "),t("h2",{attrs:{id:"usecallback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[e._v("#")]),e._v(" useCallback")]),e._v(" "),t("p",[t("code",[e._v("useCallback")]),e._v("的"),t("code",[e._v("TS")]),e._v("定义可以看出，范型"),t("code",[e._v("T")]),e._v("在"),t("code",[e._v("useCallback")]),e._v("中是一个返回的函数类型。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type DependencyList = ReadonlyArray<any>;\n\nfunction useCallback<T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T;\n")])])]),t("p",[e._v("下面是"),t("code",[e._v("useCallback")]),e._v("的简单示例，在"),t("code",[e._v("a")]),e._v("和"),t("code",[e._v("b")]),e._v("的变量值不变的情况下，"),t("code",[e._v("memoizedCallback")]),e._v("的函数引用不变，在此时"),t("code",[e._v("useCallback")]),e._v("函数的第一个参数不会被重新定义，即引用的依旧是原函数，从而达到性能优化的目的。")]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" memoizedCallback "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("useCallback")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("doSomething")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("把内联回调函数"),t("code",[e._v("callback: T")]),e._v("及依赖项数组"),t("code",[e._v("deps: DependencyList")]),e._v("作为参数传入 "),t("code",[e._v("useCallback")]),e._v("，它将返回该回调函数的"),t("code",[e._v("memoized")]),e._v("版本，该回调函数仅在某个依赖项改变时才会更新，将回调函数传递给经过优化的并使用引用相等性去避免非必要渲染(例如"),t("code",[e._v("shouldComponentUpdate")]),e._v(")的子组件时，它将非常有用。此外，"),t("code",[e._v("useCallback(fn, deps)")]),e._v("相当于"),t("code",[e._v("useMemo(() => fn, deps)")]),e._v("，由此"),t("code",[e._v("useCallback")]),e._v("可以看作"),t("code",[e._v("useMemo")]),e._v("的语法糖。"),t("br"),e._v(" "),t("code",[e._v("eslint")]),e._v("的"),t("code",[e._v("eslint-plugin-react-hooks")]),e._v("中的"),t("code",[e._v("exhaustive-deps")]),e._v("规则可以在添加错误依赖时发出警告并给出修复建议。"),t("br"),e._v("\n在"),t("code",[e._v("useCallback")]),e._v("的应用方面，在这里引用一下 @松松 给出的例子，一般"),t("code",[e._v("Js")]),e._v("上创建一个函数需要的时间并不至于要缓存的程度，那为什么要专门给缓存函数的创建做一个语法糖呢，这就跟"),t("code",[e._v("React.memo")]),e._v("有关系了。"),t("code",[e._v("React.memo")]),e._v("的默认第二参数是浅对比"),t("code",[e._v("shallow compare")]),e._v("上次渲染的"),t("code",[e._v("props")]),e._v("和这次渲染的"),t("code",[e._v("props")]),e._v("，如果你的组件的"),t("code",[e._v("props")]),e._v("中包含一个回调函数，并且这个函数是在父组件渲染的过程中创建的(见下例)，那么每次父组件(下例中的"),t("code",[e._v("<MyComponent />")]),e._v("）渲染时，"),t("code",[e._v("React")]),e._v("是认为你的子组件(下例中的"),t("code",[e._v("<Button />")]),e._v(")"),t("code",[e._v("props")]),e._v("是有变化的，不管你是否对这个子组件用了"),t("code",[e._v("React.memo")]),e._v("，都无法阻止重复渲染。这时就只能用"),t("code",[e._v("useCallback")]),e._v("来缓存这个回调函数，才会让"),t("code",[e._v("React")]),e._v("(或者说"),t("code",[e._v("Js")]),e._v(")认为这个"),t("code",[e._v("prop")]),e._v("和上次是相同的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 下面三种方法都会在MyComponent渲染的过程中重新创建这个回调函数\n// 这样都会引起Button的重新渲染 因为Button的props变化了\nfunction MyComponent() {\n  return <Button onClick={() => doWhatever()} />;\n}\n\nfunction MyComponent() {\n  const handleClick = () => doWhatever();\n  return <Button onClick={handleClick} />;\n}\n\nfunction MyComponent() {\n  function handleClick(){ \n    doWhatever();\n  }\n  return <Button onClick={handleClick} />;\n}\n\n// 只有使用useCallback， 才会导致即使MyComponent渲染，也不重新创建一个新的回调函数\n// 这样就不会引发Button的重新渲染 因为Button的props没变\nfunction MyComponent() {\n  const handleClick = React.useCallBack(() => doWhatever(), []);\n  return <Button onClick={handleClick} />;\n}\n")])])]),t("h2",{attrs:{id:"最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[e._v("#")]),e._v(" 最后")]),e._v(" "),t("p",[e._v("关于"),t("code",[e._v("useMemo")]),e._v("与"),t("code",[e._v("useCallback")]),e._v("是否值得尽量多用，私认为并不应该这么做，如果在性能优化方面非常有效，值得在每个依赖或者函数都值得使用"),t("code",[e._v("useMemo")]),e._v("与"),t("code",[e._v("useCallback")]),e._v("的话，"),t("code",[e._v("React")]),e._v("可以干脆将其作为默认的功能，又可以减少用户使用"),t("code",[e._v("Hooks")]),e._v("的心智负担，又可以减少使用"),t("code",[e._v("Hooks")]),e._v("的包裹让代码更加简洁，可是"),t("code",[e._v("React")]),e._v("并没有这么做，实际上这仍然是一个权衡的问题，权衡性能优化的点，取一个折衷，具体来说就是你需要评估你组件"),t("code",[e._v("re-render")]),e._v(" 的次数和代价，"),t("code",[e._v("React.memo")]),e._v("、"),t("code",[e._v("useMemo")]),e._v("与"),t("code",[e._v("useCallback")]),e._v("这些缓存机制也是有代价的，需要做好平衡，不能盲目的多用这类缓存优化方案，比起盲目的进行各种细微的优化，分析清楚性能问题出现的原因才能真正的解决问题。")]),e._v(" "),t("h2",{attrs:{id:"每日一题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#每日一题"}},[e._v("#")]),e._v(" 每日一题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("https://github.com/WindrunnerMax/EveryDay\n")])])]),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("https://www.zhihu.com/question/428921970\nhttps://www.zhihu.com/question/390974405\nhttps://juejin.cn/post/6844904032113278990\nhttps://juejin.cn/post/6844904001998176263\nhttps://segmentfault.com/a/1190000039405417\nhttps://www.infoq.cn/article/mm5btiwipppnpjhjqgtr\nhttps://zh-hans.reactjs.org/docs/hooks-reference.html\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);