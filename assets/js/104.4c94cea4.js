(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{377:function(t,e,s){"use strict";s.r(e);var a=s(14),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"有状态和无状态组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有状态和无状态组件"}},[t._v("#")]),t._v(" 有状态和无状态组件")]),t._v(" "),e("p",[t._v("组件是自我维持的、独立的微实体，其描述了"),e("code",[t._v("UI")]),t._v("的一部分，可以将应用程序的"),e("code",[t._v("UI")]),t._v("拆分为较小的组件，其中每个组件都有自己的代码、结构和"),e("code",[t._v("API")]),t._v("，简单来说组件允许你将"),e("code",[t._v("UI")]),t._v("拆分为独立可复用的代码片段，并对每个片段进行独立构思。")]),t._v(" "),e("h2",{attrs:{id:"描述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[e("code",[t._v("React")]),t._v("中的组件按状态主要分为无状态组件和有状态组件两类，通常来说，使用"),e("code",[t._v("class")]),t._v("关键字创建的组件，有自己的私有数据"),e("code",[t._v("this.state")]),t._v("和生命周期函数就是有状态组件，使用"),e("code",[t._v("function")]),t._v("创建的组件，只有"),e("code",[t._v("props")]),t._v("没有自己的私有数据和生命周期函数就是无状态组件。")]),t._v(" "),e("h3",{attrs:{id:"无状态组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#无状态组件"}},[t._v("#")]),t._v(" 无状态组件")]),t._v(" "),e("p",[t._v("无状态组件"),e("code",[t._v("Stateless Component")]),t._v("是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种"),e("code",[t._v("UI")]),t._v("库里也是最开始会开发的组件类别，例如按钮、标签、输入框等。其的基本组成结构就是属性"),e("code",[t._v("props")]),t._v("以及事件函数调用。由于不涉及到状态的更新，所以这种组件的复用性也最强，无状态组件由于没有自己的"),e("code",[t._v("state")]),t._v("和生命周期函数，所以运行效率高。")]),t._v(" "),e("ul",[e("li",[t._v("只负责接收"),e("code",[t._v("props")]),t._v("渲染"),e("code",[t._v("DOM")]),t._v("，不维护自己的"),e("code",[t._v("state")]),t._v("。")]),t._v(" "),e("li",[t._v("不能访问生命周期方法。")]),t._v(" "),e("li",[t._v("不需要声明类，可以避免"),e("code",[t._v("extends")]),t._v("或"),e("code",[t._v("constructor")]),t._v("之类的代码，语法上更加简洁。")]),t._v(" "),e("li",[t._v("不会被实例化，因此不能直接传"),e("code",[t._v("ref")]),t._v("，可以使用"),e("code",[t._v("React.forwardRef")]),t._v("包装后再传"),e("code",[t._v("ref")]),t._v("。")]),t._v(" "),e("li",[t._v("不需要显示声明"),e("code",[t._v("this")]),t._v("关键字，在"),e("code",[t._v("ES6")]),t._v("的类声明中往往需要将函数的"),e("code",[t._v("this")]),t._v("关键字绑定到当前作用域，而因为函数式声明的特性，我们不需要再强制绑定。")]),t._v(" "),e("li",[t._v("更好的性能表现，因为函数式组件中并不需要进行生命周期的管理与状态管理，因此"),e("code",[t._v("React")]),t._v("并不需要进行某些特定的检查或者内存分配，从而保证了更好地性能表现。")])]),t._v(" "),e("p",[t._v("简单来说如果一个组件不需要管理"),e("code",[t._v("state")]),t._v("而只是纯粹的展示，那么就可以定义成无状态组件。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Hello(props) { \n    return (\n        <div>Hello {props.name}</div>\n    )\n} \n")])])]),e("p",[t._v("对于这种无状态的组件，使用函数式的方式声明，会使得代码的可读性更好，并能大大减少代码量，使用箭头函数能够使代码更加简洁。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const Todo = (props) => ( \n    <div onClick={props.onClick}>{props.text}</div> \n)\n")])])]),e("h3",{attrs:{id:"有状态组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有状态组件"}},[t._v("#")]),t._v(" 有状态组件")]),t._v(" "),e("p",[t._v("有状态组件"),e("code",[t._v("Stateful Component")]),t._v("是在无状态组件的基础上，如果组件内部包含状态"),e("code",[t._v("state")]),t._v("且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件。有状态组件通常会带有生命周期"),e("code",[t._v("lifecycle")]),t._v("，用以在不同的时刻触发状态的更新。这种组件也是通常在写业务逻辑中最经常使用到的，根据不同的业务场景组件的状态数量以及生命周期机制也不尽相同。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class Hello extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = { \n      tips: "Hello World!"\n    }\n  }\n  componentDidMount() {\n    console.log("ComponentDidMount", this);\n  }\n  componentWillUnmount() {\n    console.log("ComponentWillUnmount", this);\n  }\n  render() {\n    return (\n      <div>{this.state.tips}</div>\n    );\n  }\n}\n\n')])])]),e("h2",{attrs:{id:"每日一题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#每日一题"}},[t._v("#")]),t._v(" 每日一题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("https://github.com/WindrunnerMax/EveryDay\n")])])]),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("https://www.jianshu.com/p/63569386befc\nhttps://juejin.cn/post/6844903597147160584\nhttps://juejin.cn/post/6844903493816303624\nhttps://blog.csdn.net/cunjie3951/article/details/106919202\nhttps://blog.csdn.net/weixin_30819085/article/details/99989723\nhttps://setcina.github.io/2019/03/07/react%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);